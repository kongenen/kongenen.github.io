(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{435:function(v,_,t){"use strict";t.r(_);var s=t(11),e=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"第二章-变量和基本类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二章-变量和基本类型"}},[v._v("#")]),v._v(" 第二章 变量和基本类型")]),v._v(" "),_("p",[v._v("任何常用的编程语言都具备一组公共的语法特征，最基本的特征包括：")]),v._v(" "),_("ul",[_("li",[v._v("整型、字符型等内置类型")]),v._v(" "),_("li",[v._v("变量，用来为对象命名")]),v._v(" "),_("li",[v._v("表达式和语句，用于操作上述数据类型的具体值")]),v._v(" "),_("li",[v._v("if 或 while 等控制结构，有选择地执行一些语句或重复地执行一些语句")]),v._v(" "),_("li",[v._v("函数，用于定义可供随时调用的计算单元")])]),v._v(" "),_("p",[v._v("大多数编程语言通过两种方式来进一步补充其基本特征：")]),v._v(" "),_("ul",[_("li",[v._v("自定义数据类型，实现对语言的扩展")]),v._v(" "),_("li",[v._v("将一些有用的功能封装成库函数")])]),v._v(" "),_("h3",{attrs:{id:"基本内置类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本内置类型"}},[v._v("#")]),v._v(" 基本内置类型")]),v._v(" "),_("p",[_("strong",[v._v("基本算数类型")]),v._v("：")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("类型")]),v._v(" "),_("th",[v._v("含义")]),v._v(" "),_("th",[v._v("最小尺寸")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("bool")])]),v._v(" "),_("td",[v._v("布尔类型")]),v._v(" "),_("td",[v._v("8bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("char")])]),v._v(" "),_("td",[v._v("字符")]),v._v(" "),_("td",[v._v("8bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("wchar_t")])]),v._v(" "),_("td",[v._v("宽字符")]),v._v(" "),_("td",[v._v("16bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("char16_t")])]),v._v(" "),_("td",[v._v("Unicode字符")]),v._v(" "),_("td",[v._v("16bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("char32_t")])]),v._v(" "),_("td",[v._v("Unicode字符")]),v._v(" "),_("td",[v._v("32bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("short")])]),v._v(" "),_("td",[v._v("短整型")]),v._v(" "),_("td",[v._v("16bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("int")])]),v._v(" "),_("td",[v._v("整型")]),v._v(" "),_("td",[v._v("16bits (在32位机器中是32bits)")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("long")])]),v._v(" "),_("td",[v._v("长整型")]),v._v(" "),_("td",[v._v("32bits")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("long long")])]),v._v(" "),_("td",[v._v("长整型")]),v._v(" "),_("td",[v._v("64bits （是在C++11中新定义的）")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("float")])]),v._v(" "),_("td",[v._v("单精度浮点数")]),v._v(" "),_("td",[v._v("6位有效数字")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("double")])]),v._v(" "),_("td",[v._v("双精度浮点数")]),v._v(" "),_("td",[v._v("10位有效数字")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("long double")])]),v._v(" "),_("td",[v._v("扩展精度浮点数")]),v._v(" "),_("td",[v._v("10位有效数字")])])])]),v._v(" "),_("h3",{attrs:{id:"如何选择类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何选择类型"}},[v._v("#")]),v._v(" 如何选择类型")]),v._v(" "),_("ul",[_("li",[v._v("1.当明确知晓数值不可能是负数时，选用无符号类型；")]),v._v(" "),_("li",[v._v("2.使用"),_("code",[v._v("int")]),v._v("执行整数运算。一般"),_("code",[v._v("long")]),v._v("的大小和"),_("code",[v._v("int")]),v._v("一样，而"),_("code",[v._v("short")]),v._v("常常显得太小。除非超过了"),_("code",[v._v("int")]),v._v("的范围，选择"),_("code",[v._v("long long")]),v._v("。")]),v._v(" "),_("li",[v._v("3.算术表达式中不要使用"),_("code",[v._v("char")]),v._v("或"),_("code",[v._v("bool")]),v._v("。")]),v._v(" "),_("li",[v._v("4.浮点运算选用"),_("code",[v._v("double")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[v._v("#")]),v._v(" 类型转换")]),v._v(" "),_("ul",[_("li",[v._v("非布尔型赋给布尔型，初始值为0则结果为false，否则为true。")]),v._v(" "),_("li",[v._v("布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。")])]),v._v(" "),_("h3",{attrs:{id:"字面值常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字面值常量"}},[v._v("#")]),v._v(" 字面值常量")]),v._v(" "),_("ul",[_("li",[v._v("一个形如"),_("code",[v._v("42")]),v._v("的值被称作"),_("strong",[v._v("字面值常量")]),v._v("（literal）。\n"),_("ul",[_("li",[v._v("整型和浮点型字面值。")]),v._v(" "),_("li",[v._v("字符和字符串字面值。\n"),_("ul",[_("li",[v._v("使用空格连接，继承自C。")]),v._v(" "),_("li",[v._v("字符字面值：单引号， "),_("code",[v._v("'a'")])]),v._v(" "),_("li",[v._v("字符串字面值：双引号， "),_("code",[v._v('"Hello World"')])]),v._v(" "),_("li",[v._v("分多行书写字符串。"),_("div",{staticClass:"language-c++ line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v('std:cout<<"wow, a really, really long string"\n          "literal that spans two lines" <<std::endl;\n')])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])])])])]),v._v(" "),_("li",[v._v("转义序列。"),_("code",[v._v("\\n")]),v._v("、"),_("code",[v._v("\\t")]),v._v("等。")]),v._v(" "),_("li",[v._v("布尔字面值。"),_("code",[v._v("true")]),v._v("，"),_("code",[v._v("false")]),v._v("。")]),v._v(" "),_("li",[v._v("指针字面值。"),_("code",[v._v("nullptr")])])])])]),v._v(" "),_("blockquote",[_("p",[v._v("字符串型实际上时常量字符构成的数组，结尾处以"),_("code",[v._v("'\\0'")]),v._v("结束，所以字符串类型实际上长度比内容多1。")])]),v._v(" "),_("h2",{attrs:{id:"变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[v._v("#")]),v._v(" 变量")]),v._v(" "),_("p",[_("strong",[v._v("变量")]),v._v("提供一个"),_("strong",[v._v("具名")]),v._v("的、可供程序操作的存储空间。   "),_("code",[v._v("C++")]),v._v("中"),_("strong",[v._v("变量")]),v._v("和"),_("strong",[v._v("对象")]),v._v("一般可以互换使用。")]),v._v(" "),_("h3",{attrs:{id:"变量定义（define）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量定义（define）"}},[v._v("#")]),v._v(" 变量定义（define）")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("定义形式")]),v._v("：类型说明符（type specifier） + 一个或多个变量名组成的列表。如"),_("code",[v._v("int sum = 0, value, units_sold = 0;")])]),v._v(" "),_("li",[_("strong",[v._v("初始化")]),v._v("（initialize）：对象在创建时获得了一个特定的值。\n"),_("ul",[_("li",[_("strong",[v._v("初始化不是赋值！")]),v._v("：")]),v._v(" "),_("li",[v._v("初始化 = 创建变量 + 赋予初始值")]),v._v(" "),_("li",[v._v("赋值 = 擦除对象的当前值 + 用新值代替")]),v._v(" "),_("li",[_("strong",[v._v("列表初始化")]),v._v("：使用花括号"),_("code",[v._v("{}")]),v._v("，如"),_("code",[v._v("int units_sold{0};")])]),v._v(" "),_("li",[v._v("默认初始化：定义时没有指定初始值会被默认初始化；"),_("strong",[v._v("在函数体内部的内置类型变量将不会被初始化")]),v._v("。")]),v._v(" "),_("li",[v._v("建议初始化每一个内置类型的变量。")])])])]),v._v(" "),_("h3",{attrs:{id:"变量的声明（declaration）-vs-定义（define）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量的声明（declaration）-vs-定义（define）"}},[v._v("#")]),v._v(" 变量的"),_("strong",[v._v("声明")]),v._v("（declaration） vs "),_("strong",[v._v("定义")]),v._v("（define）")]),v._v(" "),_("ul",[_("li",[v._v("为了支持分离式编译，"),_("code",[v._v("C++")]),v._v("将声明和定义区分开。"),_("strong",[v._v("声明")]),v._v("使得名字为程序所知。"),_("strong",[v._v("定义")]),v._v("负责创建与名字关联的实体。")]),v._v(" "),_("li",[_("strong",[v._v("extern")]),v._v("：只是说明变量定义在其他地方。")]),v._v(" "),_("li",[v._v("只声明而不定义： 在变量名前添加关键字 "),_("code",[v._v("extern")]),v._v("，如"),_("code",[v._v("extern int i;")]),v._v("。但如果包含了初始值，就变成了定义："),_("code",[v._v("extern double pi = 3.14;")])]),v._v(" "),_("li",[v._v("变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。")]),v._v(" "),_("li",[v._v("名字的"),_("strong",[v._v("作用域")]),v._v("（namescope）"),_("code",[v._v("{}")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("第一次使用变量时再定义它")]),v._v("。")]),v._v(" "),_("li",[v._v("嵌套的作用域\n"),_("ul",[_("li",[v._v("同时存在全局和局部变量时，已定义局部变量的作用域中可用"),_("code",[v._v("::reused")]),v._v("显式访问全局变量reused。")]),v._v(" "),_("li",[_("strong",[v._v("但是用到全局变量时，尽量不适用重名的局部变量。")])])])])])])]),v._v(" "),_("h4",{attrs:{id:"变量命名规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量命名规范"}},[v._v("#")]),v._v(" 变量命名规范")]),v._v(" "),_("ol",[_("li",[v._v("需体现实际意义")]),v._v(" "),_("li",[v._v("变量名用小写字母")]),v._v(" "),_("li",[v._v("自定义类名用大写字母开头：Sales_item")]),v._v(" "),_("li",[v._v("标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。")])]),v._v(" "),_("h2",{attrs:{id:"左值和右值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#左值和右值"}},[v._v("#")]),v._v(" 左值和右值")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("左值")]),v._v("（l-value）"),_("strong",[v._v("可以")]),v._v("出现在赋值语句的左边或者右边，比如变量；")]),v._v(" "),_("li",[_("strong",[v._v("右值")]),v._v("（r-value）"),_("strong",[v._v("只能")]),v._v("出现在赋值语句的右边，比如常量。")])]),v._v(" "),_("h2",{attrs:{id:"复合类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#复合类型"}},[v._v("#")]),v._v(" 复合类型")]),v._v(" "),_("h3",{attrs:{id:"引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[v._v("#")]),v._v(" 引用")]),v._v(" "),_("blockquote",[_("p",[v._v("一般说的引用是指的左值引用")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("引用")]),v._v("：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如"),_("code",[v._v("int &refVal = val;")]),v._v("。")]),v._v(" "),_("li",[v._v("引用必须初始化。")]),v._v(" "),_("li",[v._v("引用和它的初始值是"),_("strong",[v._v("绑定bind")]),v._v("在一起的，而"),_("strong",[v._v("不是拷贝")]),v._v("。一旦定义就不能更改绑定为其他的对象")])]),v._v(" "),_("h3",{attrs:{id:"指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指针"}},[v._v("#")]),v._v(" 指针")]),v._v(" "),_("blockquote",[_("p",[v._v("int *p;      //"),_("strong",[v._v("指向int型对象")]),v._v("的指针")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("是一种 "),_("code",[v._v('"指向（point to）"')]),v._v("另外一种类型的复合类型。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("定义")]),v._v("指针类型： "),_("code",[v._v("int *ip1;")]),v._v("，"),_("strong",[v._v("从右向左读有助于阅读")]),v._v("，"),_("code",[v._v("ip1")]),v._v("是指向"),_("code",[v._v("int")]),v._v("类型的指针。")])]),v._v(" "),_("li",[_("p",[v._v("指针存放某个对象的"),_("strong",[v._v("地址")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("获取对象的地址： "),_("code",[v._v("int i=42; int *p = &i;")]),v._v("。 "),_("code",[v._v("&")]),v._v("是"),_("strong",[v._v("取地址符")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）")])]),v._v(" "),_("li",[_("p",[v._v("指针的值的四种状态：")]),v._v(" "),_("ul",[_("li",[v._v("1.指向一个对象；")]),v._v(" "),_("li",[v._v("2.指向紧邻对象的下一个位置；")]),v._v(" "),_("li",[v._v("3.空指针；")]),v._v(" "),_("li",[v._v("4.无效指针。")]),v._v(" "),_("li",[_("blockquote",[_("p",[_("strong",[v._v("对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的")])])])])])]),v._v(" "),_("li",[_("p",[v._v("指针访问对象： "),_("code",[v._v("cout << *p;")]),v._v("输出p指针所指对象的数据， "),_("code",[v._v("*")]),v._v("是"),_("strong",[v._v("解引用符")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("空指针不指向任何对象。使用"),_("code",[v._v("int *p=nullptr;")]),v._v("来使用空指针。")])]),v._v(" "),_("li",[_("blockquote",[_("p",[v._v("指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。")])])]),v._v(" "),_("li",[_("blockquote",[_("p",[v._v("赋值语句永远改变的是"),_("strong",[v._v("左侧")]),v._v("的对象。")])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("void*")]),v._v("指针可以存放"),_("strong",[v._v("任意")]),v._v("对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。")])]),v._v(" "),_("li",[_("p",[v._v("其他指针类型必须要与所指对象"),_("strong",[v._v("严格匹配")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("两个指针相减的类型是"),_("code",[v._v("ptrdiff_t")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("建议：初始化所有指针。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("int* p1, p2;//*是对p1的修饰，所以p2还是int型")])])])]),v._v(" "),_("h2",{attrs:{id:"const限定符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#const限定符"}},[v._v("#")]),v._v(" const限定符")]),v._v(" "),_("ul",[_("li",[v._v("动机：希望定义一些不能被改变值的变量。")])]),v._v(" "),_("h3",{attrs:{id:"初始化和const"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初始化和const"}},[v._v("#")]),v._v(" 初始化和const")]),v._v(" "),_("ul",[_("li",[v._v("const对象"),_("strong",[v._v("必须初始化")]),v._v("，且"),_("strong",[v._v("不能被改变")]),v._v("。")]),v._v(" "),_("li",[v._v("const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加extern关键字即可。")])]),v._v(" "),_("h3",{attrs:{id:"const的引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#const的引用"}},[v._v("#")]),v._v(" const的引用")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("reference to const")]),v._v("（对常量的引用）：指向const对象的引用，如 "),_("code",[v._v("const int ival=1; const int &refVal = ival;")]),v._v("，可以读取但不能修改"),_("code",[v._v("refVal")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("临时量")]),v._v("（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。")]),v._v(" "),_("li",[v._v("对临时量的引用是非法行为。")])]),v._v(" "),_("h3",{attrs:{id:"指针和const"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指针和const"}},[v._v("#")]),v._v(" 指针和const")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("pointer to const")]),v._v("（指向常量的指针）：不能用于改变其所指对象的值, 如 "),_("code",[v._v("const double pi = 3.14; const double *cptr = &pi;")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("const pointer")]),v._v("：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 "),_("code",[v._v("int i = 0; int *const ptr = &i;")])])]),v._v(" "),_("h3",{attrs:{id:"顶层const"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#顶层const"}},[v._v("#")]),v._v(" 顶层const")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("顶层const")]),v._v("：指针本身是个常量。")]),v._v(" "),_("li",[_("code",[v._v("底层const")]),v._v("：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。")])]),v._v(" "),_("h3",{attrs:{id:"constexpr和常量表达式（▲可选）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#constexpr和常量表达式（▲可选）"}},[v._v("#")]),v._v(" "),_("code",[v._v("constexpr")]),v._v("和常量表达式（▲可选）")]),v._v(" "),_("ul",[_("li",[v._v("常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。")]),v._v(" "),_("li",[_("code",[v._v("C++11")]),v._v("新标准规定，允许将变量声明为"),_("code",[v._v("constexpr")]),v._v("类型以便由编译器来验证变量的值是否是一个常量的表达式。")])]),v._v(" "),_("h2",{attrs:{id:"处理类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#处理类型"}},[v._v("#")]),v._v(" 处理类型")]),v._v(" "),_("h3",{attrs:{id:"类型别名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[v._v("#")]),v._v(" 类型别名")]),v._v(" "),_("ul",[_("li",[v._v("传统别名：使用"),_("strong",[v._v("typedef")]),v._v("来定义类型的同义词。 "),_("code",[v._v("typedef double wages;")])]),v._v(" "),_("li",[v._v("新标准别名：别名声明（alias declaration）： "),_("code",[v._v("using SI = Sales_item;")]),v._v("（C++11）")])]),v._v(" "),_("div",{staticClass:"language-c++ line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("// 对于复合类型（指针等）不能代回原式来进行理解\ntypedef char *pstring;  // pstring是char*的别名\nconst pstring cstr = 0; // 指向char的常量指针\n// 如改写为const char *cstr = 0;不正确，为指向const char的指针\n\n// 辅助理解（可代回后加括号）\n// const pstring cstr = 0;代回后const (char *) cstr = 0;\n// const char *cstr = 0;即为(const char *) cstr = 0;\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br")])]),_("h3",{attrs:{id:"auto类型说明符-c-11"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#auto类型说明符-c-11"}},[v._v("#")]),v._v(" auto类型说明符 c++11")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("auto")]),v._v("类型说明符：让编译器"),_("strong",[v._v("自动推断类型")]),v._v("。")]),v._v(" "),_("li",[v._v("一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。"),_("code",[v._v("auto sz = 0, pi =3.14//错误")])]),v._v(" "),_("li",[_("code",[v._v("int i = 0, &r = i; auto a = r;")]),v._v(" 推断"),_("code",[v._v("a")]),v._v("的类型是"),_("code",[v._v("int")]),v._v("。")]),v._v(" "),_("li",[v._v("会忽略"),_("code",[v._v("顶层const")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("const int ci = 1; const auto f = ci;")]),v._v("推断类型是"),_("code",[v._v("int")]),v._v("，如果希望是顶层const需要自己加"),_("code",[v._v("const")])])]),v._v(" "),_("h3",{attrs:{id:"decltype类型指示符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#decltype类型指示符"}},[v._v("#")]),v._v(" decltype类型指示符")]),v._v(" "),_("ul",[_("li",[v._v("从表达式的类型推断出要定义的变量的类型。")]),v._v(" "),_("li",[_("strong",[v._v("decltype")]),v._v("：选择并返回操作数的"),_("strong",[v._v("数据类型")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("decltype(f()) sum = x;")]),v._v(" 推断"),_("code",[v._v("sum")]),v._v("的类型是函数"),_("code",[v._v("f")]),v._v("的返回类型。")]),v._v(" "),_("li",[v._v("不会忽略"),_("code",[v._v("顶层const")]),v._v("。")]),v._v(" "),_("li",[v._v("如果对变量加括号，编译器会将其认为是一个表达式，如int i--\x3e(i),则decltype((i))得到结果为int&引用。")]),v._v(" "),_("li",[v._v("赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。")]),v._v(" "),_("li",[_("code",[v._v("C++11")])])]),v._v(" "),_("h2",{attrs:{id:"自定义数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义数据结构"}},[v._v("#")]),v._v(" 自定义数据结构")]),v._v(" "),_("h3",{attrs:{id:"struct"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#struct"}},[v._v("#")]),v._v(" struct")]),v._v(" "),_("blockquote",[_("p",[v._v("尽量不要吧类定义和对象定义放在一起。如"),_("code",[v._v("struct Student{} xiaoming,xiaofang;")])])]),v._v(" "),_("ul",[_("li",[v._v("类可以以关键字"),_("code",[v._v("struct")]),v._v("开始，紧跟类名和类体。")]),v._v(" "),_("li",[v._v("类数据成员：类体定义类的成员。")]),v._v(" "),_("li",[_("code",[v._v("C++11")]),v._v("：可以为类数据成员提供一个"),_("strong",[v._v("类内初始值")]),v._v("（in-class initializer）。")])]),v._v(" "),_("h3",{attrs:{id:"编写自己的头文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编写自己的头文件"}},[v._v("#")]),v._v(" 编写自己的头文件")]),v._v(" "),_("ul",[_("li",[v._v("头文件通常包含哪些只能被定义一次的实体：类、"),_("code",[v._v("const")]),v._v("和"),_("code",[v._v("constexpr")]),v._v("变量。")])]),v._v(" "),_("p",[v._v("预处理器概述：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("预处理器")]),v._v("（preprocessor）：确保头文件多次包含仍能安全工作。")]),v._v(" "),_("li",[v._v("当预处理器看到"),_("code",[v._v("#include")]),v._v("标记时，会用指定的头文件内容代替"),_("code",[v._v("#include")])]),v._v(" "),_("li",[_("strong",[v._v("头文件保护符")]),v._v("（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。\n"),_("ul",[_("li",[_("code",[v._v("#indef")]),v._v("已定义时为真")]),v._v(" "),_("li",[_("code",[v._v("#inndef")]),v._v("未定义时为真")]),v._v(" "),_("li",[v._v("头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。")])])])]),v._v(" "),_("div",{staticClass:"language-c++ line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("#ifndef SALES_DATA_H  //SALES_DATA_H未定义时为真\n#define SALES_DATA_H\nstrct Sale_data{\n    ...\n}\n#endif\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br")])])])}),[],!1,null,null,null);_.default=e.exports}}]);