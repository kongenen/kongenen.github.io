(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{436:function(v,_,t){"use strict";t.r(_);var e=t(11),o=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"第五章-语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第五章-语句"}},[v._v("#")]),v._v(" 第五章 语句")]),v._v(" "),_("h2",{attrs:{id:"简单语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单语句"}},[v._v("#")]),v._v(" 简单语句")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("表达式语句")]),v._v("：一个表达式末尾加上分号，就变成了表达式语句。")]),v._v(" "),_("li",[_("strong",[v._v("空语句")]),v._v("：只有一个单独的分号。")]),v._v(" "),_("li",[_("strong",[v._v("复合语句（块）")]),v._v("：用花括号 "),_("code",[v._v("{}")]),v._v("包裹起来的语句和声明的序列。一个块就是一个作用域。")])]),v._v(" "),_("h2",{attrs:{id:"条件语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#条件语句"}},[v._v("#")]),v._v(" 条件语句")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("悬垂else")]),v._v("（dangling else）：用来描述在嵌套的"),_("code",[v._v("if else")]),v._v("语句中，如果"),_("code",[v._v("if")]),v._v("比"),_("code",[v._v("else")]),v._v("多时如何处理的问题。C++使用的方法是"),_("code",[v._v("else")]),v._v("匹配最近没有配对的"),_("code",[v._v("if")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"迭代语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭代语句"}},[v._v("#")]),v._v(" 迭代语句")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("while")]),v._v("：当不确定到底要迭代多少次时，使用 "),_("code",[v._v("while")]),v._v("循环比较合适，比如读取输入的内容。")]),v._v(" "),_("li",[_("strong",[v._v("for")]),v._v("： "),_("code",[v._v("for")]),v._v("语句可以省略掉 "),_("code",[v._v("init-statement")]),v._v("， "),_("code",[v._v("condition")]),v._v("和 "),_("code",[v._v("expression")]),v._v("的任何一个；"),_("strong",[v._v("甚至全部")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("范围for")]),v._v("： "),_("code",[v._v("for (declaration: expression) statement")])])]),v._v(" "),_("h2",{attrs:{id:"跳转语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跳转语句"}},[v._v("#")]),v._v(" 跳转语句")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("break")]),v._v("："),_("code",[v._v("break")]),v._v("语句负责终止离它最近的"),_("code",[v._v("while")]),v._v("、"),_("code",[v._v("do while")]),v._v("、"),_("code",[v._v("for")]),v._v("或者"),_("code",[v._v("switch")]),v._v("语句，并从这些语句之后的第一条语句开始继续执行。")]),v._v(" "),_("li",[_("strong",[v._v("continue")]),v._v("：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在"),_("code",[v._v("while")]),v._v("、"),_("code",[v._v("do while")]),v._v("、"),_("code",[v._v("for")]),v._v("循环的内部。")])]),v._v(" "),_("h2",{attrs:{id:"try语句块和异常处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#try语句块和异常处理"}},[v._v("#")]),v._v(" try语句块和异常处理")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("throw表达式")]),v._v("：异常检测部分使用 "),_("code",[v._v("throw")]),v._v("表达式来表示它遇到了无法处理的问题。我们说 "),_("code",[v._v("throw")]),v._v("引发 "),_("code",[v._v("raise")]),v._v("了异常。")]),v._v(" "),_("li",[_("strong",[v._v("try语句块")]),v._v("：以 "),_("code",[v._v("try")]),v._v("关键词开始，以一个或多个 "),_("code",[v._v("catch")]),v._v("字句结束。 "),_("code",[v._v("try")]),v._v("语句块中的代码抛出的异常通常会被某个 "),_("code",[v._v("catch")]),v._v("捕获并处理。 "),_("code",[v._v("catch")]),v._v("子句也被称为"),_("strong",[v._v("异常处理代码")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("异常类")]),v._v("：用于在 "),_("code",[v._v("throw")]),v._v("表达式和相关的 "),_("code",[v._v("catch")]),v._v("子句之间传递异常的具体信息。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);