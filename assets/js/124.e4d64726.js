(window.webpackJsonp=window.webpackJsonp||[]).push([[124],{445:function(_,v,e){"use strict";e.r(v);var t=e(11),d=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"第十章-泛型算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十章-泛型算法"}},[_._v("#")]),_._v(" 第十章 泛型算法")]),_._v(" "),v("h2",{attrs:{id:"泛型算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型算法"}},[_._v("#")]),_._v(" 泛型算法")]),_._v(" "),v("ul",[v("li",[_._v("因为它们实现共同的操作，所以称之为“"),v("strong",[_._v("算法")]),_._v("”；而“"),v("strong",[_._v("泛型")]),_._v("”、指的是它们可以操作在多种容器类型上。")]),_._v(" "),v("li",[_._v("泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。")]),_._v(" "),v("li",[_._v("头文件： "),v("code",[_._v("#include <algorithm>")]),_._v("或者 "),v("code",[_._v("#include <numeric>")]),_._v("(算数相关)")]),_._v(" "),v("li",[_._v("大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。")]),_._v(" "),v("li",[_._v("必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。")])]),_._v(" "),v("h3",{attrs:{id:"find"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#find"}},[_._v("#")]),_._v(" find")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);")])]),_._v(" "),v("li",[_._v("输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。")])]),_._v(" "),v("h2",{attrs:{id:"初识泛型算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初识泛型算法"}},[_._v("#")]),_._v(" 初识泛型算法")]),_._v(" "),v("ul",[v("li",[_._v("标准库提供了超过100个算法，但这些算法有一致的结构。")]),_._v(" "),v("li",[_._v("理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。")])]),_._v(" "),v("h3",{attrs:{id:"只读算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#只读算法"}},[_._v("#")]),_._v(" 只读算法")]),_._v(" "),v("ul",[v("li",[_._v("只读取范围中的元素，不改变元素。")]),_._v(" "),v("li",[_._v("如 "),v("code",[_._v("find")]),_._v("和 "),v("code",[_._v("accumulate")]),_._v("（在"),v("code",[_._v("numeric")]),_._v("中定义，求和）。")]),_._v(" "),v("li",[v("code",[_._v("find_first_of")]),_._v("，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的"),v("code",[_._v("end")]),_._v("迭代器。")]),_._v(" "),v("li",[_._v("通常最好使用"),v("code",[_._v("cbegin")]),_._v("和"),v("code",[_._v("cend")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("equal")]),_._v("：确定两个序列是否保存相同的值。")])]),_._v(" "),v("h3",{attrs:{id:"写容器元素的算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#写容器元素的算法"}},[_._v("#")]),_._v(" 写容器元素的算法")]),_._v(" "),v("ul",[v("li",[_._v("一些算法将新值赋予序列中的元素。")]),_._v(" "),v("li",[_._v("算法不检查写操作。")]),_._v(" "),v("li",[v("code",[_._v("fill")]),_._v("： "),v("code",[_._v("fill(vec.begin(), vec.end(), 0);")]),_._v(" 将每个元素重置为0")]),_._v(" "),v("li",[v("code",[_._v("fill_n")]),_._v("： "),v("code",[_._v("fill_n(vec.begin(), 10, 0);")])]),_._v(" "),v("li",[_._v("插入迭代器"),v("code",[_._v("back_inserter")]),_._v("：\n"),v("ul",[v("li",[_._v("用来确保算法有足够的空间存储数据。")]),_._v(" "),v("li",[v("code",[_._v("#include <iterator>")])]),_._v(" "),v("li",[v("code",[_._v("back_inserter(vec)")])])])]),_._v(" "),v("li",[_._v("拷贝算法"),v("code",[_._v("copy")]),_._v("：")]),_._v(" "),v("li",[_._v("输入：前两个参数指定输入范围，第三个指向目标序列。")]),_._v(" "),v("li",[v("code",[_._v("copy (ilst.begin(), ilst.end(), back_inserter(ivec));")])]),_._v(" "),v("li",[v("code",[_._v("copy")]),_._v("时必须保证目标目的序列至少要包含与输入序列一样多的元素。")])]),_._v(" "),v("h3",{attrs:{id:"重排容器元素的算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重排容器元素的算法"}},[_._v("#")]),_._v(" 重排容器元素的算法")]),_._v(" "),v("ul",[v("li",[_._v("这些算法会重排容器中元素的顺序。")]),_._v(" "),v("li",[_._v("排序算法"),v("code",[_._v("sort")]),_._v("：\n"),v("ul",[v("li",[_._v("接受两个迭代器，表示要排序的元素范围。")])])]),_._v(" "),v("li",[_._v("消除重复"),v("code",[_._v("unique")]),_._v("：\n"),v("ul",[v("li",[_._v("之前要先调用"),v("code",[_._v("sort")])]),_._v(" "),v("li",[_._v("返回的迭代器指向最后一个不重复元素之后的位置。")]),_._v(" "),v("li",[_._v("顺序会变，重复的元素被“删除”。")]),_._v(" "),v("li",[_._v("并没有真正删除，真正删除必须使用容器操作。")])])])]),_._v(" "),v("h2",{attrs:{id:"定制操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定制操作"}},[_._v("#")]),_._v(" 定制操作")]),_._v(" "),v("h3",{attrs:{id:"向算法传递函数："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#向算法传递函数："}},[_._v("#")]),_._v(" 向算法传递函数：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("谓词（"),v("code",[_._v("predicate")]),_._v("）：")]),_._v(" "),v("ul",[v("li",[_._v("是一个"),v("strong",[_._v("可调用的表达式")]),_._v("，返回结果是一个能用作条件的值")]),_._v(" "),v("li",[_._v("一元谓词：接受一个参数")]),_._v(" "),v("li",[_._v("二元谓词：接受两个参数")])])]),_._v(" "),v("li",[v("p",[_._v("例子：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("stable_sort")]),_._v("：\n"),v("ul",[v("li",[_._v("保留相等元素的原始相对位置。")]),_._v(" "),v("li",[v("code",[_._v("stable_sort(words.begin(), words.end(), isShorter);")])])])])])])]),_._v(" "),v("h3",{attrs:{id:"lambda表达式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式"}},[_._v("#")]),_._v(" lambda表达式")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("有时可能希望操作可以接受更多的参数。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("lambda")]),_._v("表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。")])]),_._v(" "),v("li",[v("p",[_._v("形式："),v("code",[_._v("[capture list](parameter list) -> return type {function body}")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("其中"),v("code",[_._v("capture list")]),_._v("捕获列表是一个"),v("code",[_._v("lambda")]),_._v("所在函数定义的局部变量的列表（通常为空）。不可忽略。")]),_._v(" "),v("li",[v("code",[_._v("return type")]),_._v("是返回类型。可忽略。")]),_._v(" "),v("li",[v("code",[_._v("parameter")]),_._v("是参数列表。可忽略。")]),_._v(" "),v("li",[v("code",[_._v("function body")]),_._v("是函数体。不可忽略。")]),_._v(" "),v("li",[v("code",[_._v("auto f = [] {return 42;}")])])])]),_._v(" "),v("li",[v("p",[_._v("例子：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("find_if")]),_._v(":\n"),v("ul",[v("li",[_._v("接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。")]),_._v(" "),v("li",[v("code",[_._v("auto wc = find_if(words.begin(), words.end(), [sz](const string &a){return a.size() >= sz;});")])])])]),_._v(" "),v("li",[v("code",[_._v("for_each")]),_._v("：\n"),v("ul",[v("li",[_._v("接受一个可调用对象，并对序列中每个元素调用此对象。")]),_._v(" "),v("li",[v("code",[_._v('for_each(wc, words.end(), [](const string &s){cout << s << " ";})')])])])])])])]),_._v(" "),v("h3",{attrs:{id:"lambda捕获和返回"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lambda捕获和返回"}},[_._v("#")]),_._v(" lambda捕获和返回")]),_._v(" "),v("ul",[v("li",[_._v("定义"),v("code",[_._v("lambda")]),_._v("时会生成一个新的类类型和该类型的一个对象。")]),_._v(" "),v("li",[_._v("默认情况下，从"),v("code",[_._v("lambda")]),_._v("生成的类都包含一个对应该"),v("code",[_._v("lambda")]),_._v("所捕获的变量的数据成员，在"),v("code",[_._v("lambda")]),_._v("对象创建时被初始化。")]),_._v(" "),v("li",[v("strong",[_._v("值捕获")]),_._v("：前提是变量可以拷贝，"),v("code",[_._v("size_t v1 = 42; auto f = [v1] {return v1;};")]),_._v("。")]),_._v(" "),v("li",[v("strong",[_._v("引用捕获")]),_._v("：必须保证在"),v("code",[_._v("lambda")]),_._v("执行时，变量是存在的，"),v("code",[_._v("auto f2 = [&v1] {return v1;};")])]),_._v(" "),v("li",[_._v("尽量减少捕获的数据量，尽可能避免捕获指针或引用。")]),_._v(" "),v("li",[v("strong",[_._v("隐式捕获")]),_._v("：让编译器推断捕获列表，在捕获列表中写一个"),v("code",[_._v("&")]),_._v("（引用方式）或"),v("code",[_._v("=")]),_._v("（值方式）。"),v("code",[_._v("auto f3 = [=] {return v1;}")])])]),_._v(" "),v("p",[v("strong",[_._v("lambda捕获列表")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("捕获列表")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("[]")])]),_._v(" "),v("td",[_._v("空捕获列表。"),v("code",[_._v("lambda")]),_._v("不能使用所在函数中的变量。一个"),v("code",[_._v("lambda")]),_._v("只有在捕获变量后才能使用它们。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("[names]")])]),_._v(" "),v("td",[v("code",[_._v("names")]),_._v("是一个逗号分隔的名字列表，这些名字都是在"),v("code",[_._v("lambda")]),_._v("所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了"),v("code",[_._v("&")]),_._v("，则采用引用捕获方式。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("[&]")])]),_._v(" "),v("td",[_._v("隐式捕获列表，采用引用捕获方式。"),v("code",[_._v("lambda")]),_._v("体中所使用的来自所在函数的实体都采用引用方式使用。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("[=]")])]),_._v(" "),v("td",[_._v("隐式捕获列表，采用值捕获方式。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("[&, identifier_list]")])]),_._v(" "),v("td",[v("code",[_._v("identifier_list")]),_._v("是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。"),v("code",[_._v("identifier_list")]),_._v("中的名字前面不能使用"),v("code",[_._v("&")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("[=, identifier_list]")])]),_._v(" "),v("td",[v("code",[_._v("identifier_list")]),_._v("中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。"),v("code",[_._v("identifier_list")]),_._v("中的名字不能包括"),v("code",[_._v("this")]),_._v("，且前面必须使用"),v("code",[_._v("&")])])])])]),_._v(" "),v("h3",{attrs:{id:"参数绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参数绑定"}},[_._v("#")]),_._v(" 参数绑定")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("lambda")]),_._v("表达式更适合在一两个地方使用的简单操作。")]),_._v(" "),v("li",[_._v("如果是很多地方使用相同的操作，还是需要定义函数。")]),_._v(" "),v("li",[_._v("函数如何包装成一元谓词？使用参数绑定。")]),_._v(" "),v("li",[_._v("标准库"),v("code",[_._v("bind")]),_._v("函数：\n"),v("ul",[v("li",[_._v("定义在头文件"),v("code",[_._v("functional")]),_._v("中，可以看做为一个通用的函数适配器。")]),_._v(" "),v("li",[v("code",[_._v("auto newCallable = bind(callable, arg_list);")])]),_._v(" "),v("li",[_._v("我们再调用"),v("code",[_._v("newCallable")]),_._v("的时候，"),v("code",[_._v("newCallable")]),_._v("会调用"),v("code",[_._v("callable")]),_._v("并传递给它"),v("code",[_._v("arg_list")]),_._v("中的参数。")]),_._v(" "),v("li",[v("code",[_._v("_n")]),_._v("代表第n个位置的参数。定义在"),v("code",[_._v("placeholders")]),_._v("的命名空间中。"),v("code",[_._v("using std::placeholder::_1;")])]),_._v(" "),v("li",[v("code",[_._v("auto g = bind(f, a, b, _2, c, _1);")]),_._v("，调用"),v("code",[_._v("g(_1, _2)")]),_._v("实际上调用"),v("code",[_._v("f(a, b, _2, c, _1)")])]),_._v(" "),v("li",[_._v("非占位符的参数要使用引用传参，必须使用标准库"),v("code",[_._v("ref")]),_._v("函数或者"),v("code",[_._v("cref")]),_._v("函数。")])])])]),_._v(" "),v("h2",{attrs:{id:"再探迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#再探迭代器"}},[_._v("#")]),_._v(" 再探迭代器")]),_._v(" "),v("h3",{attrs:{id:"插入迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#插入迭代器"}},[_._v("#")]),_._v(" 插入迭代器")]),_._v(" "),v("ul",[v("li",[_._v("插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。")]),_._v(" "),v("li",[_._v("三种类型：\n"),v("ul",[v("li",[v("code",[_._v("back_inserter")]),_._v("：创建一个使用"),v("code",[_._v("push_back")]),_._v("的迭代器。")]),_._v(" "),v("li",[v("code",[_._v("front_inserter")]),_._v("创建一个使用"),v("code",[_._v("push_front")]),_._v("的迭代器。")]),_._v(" "),v("li",[v("code",[_._v("inserter")]),_._v("创建一个使用"),v("code",[_._v("insert")]),_._v("的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。")])])])]),_._v(" "),v("p",[v("strong",[_._v("插入迭代器操作")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("it=t")])]),_._v(" "),v("td",[_._v("在"),v("code",[_._v("it")]),_._v("指定的当前位置插入值"),v("code",[_._v("t")]),_._v("。假定"),v("code",[_._v("c")]),_._v("是"),v("code",[_._v("it")]),_._v("绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用"),v("code",[_._v("c.push_back(t)")]),_._v("、"),v("code",[_._v("c.push_front(t)")]),_._v("、"),v("code",[_._v("c.insert(t, p)")]),_._v("，其中"),v("code",[_._v("p")]),_._v("是传递给"),v("code",[_._v("inserter")]),_._v("的迭代器位置")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("*it, ++it, it++")])]),_._v(" "),v("td",[_._v("这些操作虽然存在，但不会对"),v("code",[_._v("it")]),_._v("做任何事情，每个操作都返回"),v("code",[_._v("it")])])])])]),_._v(" "),v("h3",{attrs:{id:"iostream迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iostream迭代器"}},[_._v("#")]),_._v(" iostream迭代器")]),_._v(" "),v("ul",[v("li",[_._v("迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。")]),_._v(" "),v("li",[_._v("通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。")])]),_._v(" "),v("p",[v("strong",[_._v("istream_iterator的操作")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("istream_iterator<T> in(is);")])]),_._v(" "),v("td",[v("code",[_._v("in")]),_._v("从输入流"),v("code",[_._v("is")]),_._v("读取类型为"),v("code",[_._v("T")]),_._v("的值")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("istream_iterator<T> end;")])]),_._v(" "),v("td",[_._v("读取类型是"),v("code",[_._v("T")]),_._v("的值的"),v("code",[_._v("istream_iterator")]),_._v("迭代器，表示尾后位置")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("in1 == in2")])]),_._v(" "),v("td",[v("code",[_._v("in1")]),_._v("和"),v("code",[_._v("in2")]),_._v("必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("in1 != in2")])]),_._v(" "),v("td",[_._v("类似上条")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("*in")])]),_._v(" "),v("td",[_._v("返回从流中读取的值")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("in->mem")])]),_._v(" "),v("td",[_._v("与"),v("code",[_._v("*(in).mem")]),_._v("含义相同")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("++in, in++")])]),_._v(" "),v("td",[_._v("使用元素类型所定义的"),v("code",[_._v(">>")]),_._v("运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。")])])])]),_._v(" "),v("p",[v("strong",[_._v("ostream_iterator的操作")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("ostream_iterator<T> out(os);")])]),_._v(" "),v("td",[v("code",[_._v("out")]),_._v("将类型为"),v("code",[_._v("T")]),_._v("的值写到输出流"),v("code",[_._v("os")]),_._v("中")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("ostream_iterator<T> out(os, d);")])]),_._v(" "),v("td",[v("code",[_._v("out")]),_._v("将类型为"),v("code",[_._v("T")]),_._v("的值写到输出流"),v("code",[_._v("os")]),_._v("中，每个值后面都输出一个"),v("code",[_._v("d")]),_._v("。"),v("code",[_._v("d")]),_._v("指向一个空字符结尾的字符数组。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("out = val")])]),_._v(" "),v("td",[_._v("用"),v("code",[_._v("<<")]),_._v("运算符将"),v("code",[_._v("val")]),_._v("写入到"),v("code",[_._v("out")]),_._v("所绑定的"),v("code",[_._v("ostream")]),_._v("中。"),v("code",[_._v("val")]),_._v("的类型必须和"),v("code",[_._v("out")]),_._v("可写的类型兼容。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("*out, ++out, out++")])]),_._v(" "),v("td",[_._v("这些运算符是存在的，但不对"),v("code",[_._v("out")]),_._v("做任何事情。每个运算符都返回"),v("code",[_._v("out")]),_._v("。")])])])]),_._v(" "),v("h3",{attrs:{id:"反向迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反向迭代器"}},[_._v("#")]),_._v(" 反向迭代器")]),_._v(" "),v("ul",[v("li",[_._v("反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。")]),_._v(" "),v("li",[_._v("对于反向迭代器，递增和递减的操作含义会颠倒。")]),_._v(" "),v("li",[_._v("实现向后遍历，配合"),v("code",[_._v("rbegin")]),_._v("和"),v("code",[_._v("rend")]),_._v("。")])]),_._v(" "),v("h2",{attrs:{id:"泛型算法结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型算法结构"}},[_._v("#")]),_._v(" 泛型算法结构")]),_._v(" "),v("h3",{attrs:{id:"_5类迭代器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5类迭代器"}},[_._v("#")]),_._v(" 5类迭代器")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("迭代器类别")]),_._v(" "),v("th",[_._v("解释")]),_._v(" "),v("th",[_._v("支持的操作")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("输入迭代器")]),_._v(" "),v("td",[_._v("只读，不写；单遍扫描，只能递增")]),_._v(" "),v("td",[v("code",[_._v("==")]),_._v(","),v("code",[_._v("!=")]),_._v(","),v("code",[_._v("++")]),_._v(","),v("code",[_._v("*")]),_._v(","),v("code",[_._v("->")])])]),_._v(" "),v("tr",[v("td",[_._v("输出迭代器")]),_._v(" "),v("td",[_._v("只写，不读；单遍扫描，只能递增")]),_._v(" "),v("td",[v("code",[_._v("++")]),_._v(","),v("code",[_._v("*")])])]),_._v(" "),v("tr",[v("td",[_._v("前向迭代器")]),_._v(" "),v("td",[_._v("可读写；多遍扫描，只能递增")]),_._v(" "),v("td",[v("code",[_._v("==")]),_._v(","),v("code",[_._v("!=")]),_._v(","),v("code",[_._v("++")]),_._v(","),v("code",[_._v("*")]),_._v(","),v("code",[_._v("->")])])]),_._v(" "),v("tr",[v("td",[_._v("双向迭代器")]),_._v(" "),v("td",[_._v("可读写；多遍扫描，可递增递减")]),_._v(" "),v("td",[v("code",[_._v("==")]),_._v(","),v("code",[_._v("!=")]),_._v(","),v("code",[_._v("++")]),_._v(","),v("code",[_._v("--")]),_._v(","),v("code",[_._v("*")]),_._v(","),v("code",[_._v("->")])])]),_._v(" "),v("tr",[v("td",[_._v("随机访问迭代器")]),_._v(" "),v("td",[_._v("可读写，多遍扫描，支持全部迭代器运算")]),_._v(" "),v("td",[v("code",[_._v("==")]),_._v(","),v("code",[_._v("!=")]),_._v(","),v("code",[_._v("<")]),_._v(","),v("code",[_._v("<=")]),_._v(","),v("code",[_._v(">")]),_._v(","),v("code",[_._v(">=")]),_._v(","),v("code",[_._v("++")]),_._v(","),v("code",[_._v("--")]),_._v(","),v("code",[_._v("+")]),_._v(","),v("code",[_._v("+=")]),_._v(","),v("code",[_._v("-")]),_._v(","),v("code",[_._v("-=")]),_._v(","),v("code",[_._v("*")]),_._v(","),v("code",[_._v("->")]),_._v(","),v("code",[_._v("iter[n]")]),_._v("=="),v("code",[_._v("*(iter[n])")])])])])]),_._v(" "),v("h3",{attrs:{id:"算法的形参模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法的形参模式"}},[_._v("#")]),_._v(" 算法的形参模式")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("alg(beg, end, other args);")])]),_._v(" "),v("li",[v("code",[_._v("alg(beg, end, dest, other args);")])]),_._v(" "),v("li",[v("code",[_._v("alg(beg, end, beg2, other args);")])]),_._v(" "),v("li",[v("code",[_._v("alg(beg, end, beg2, end2, other args);")])])]),_._v(" "),v("p",[_._v("其中，"),v("code",[_._v("alg")]),_._v("是算法名称，"),v("code",[_._v("beg")]),_._v("和"),v("code",[_._v("end")]),_._v("表示算法所操作的输入范围。"),v("code",[_._v("dest")]),_._v("、"),v("code",[_._v("beg2")]),_._v("、"),v("code",[_._v("end2")]),_._v("都是迭代器参数，是否使用要依赖于执行的操作。")]),_._v(" "),v("h3",{attrs:{id:"算法命名规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法命名规范"}},[_._v("#")]),_._v(" 算法命名规范")]),_._v(" "),v("ul",[v("li",[_._v("一些算法使用重载形式传递一个谓词。")]),_._v(" "),v("li",[_._v("接受一个元素值的算法通常有一个"),v("strong",[_._v("不同名")]),_._v("的版本：加"),v("code",[_._v("_if")]),_._v("，接受一个谓词代替元素值。")]),_._v(" "),v("li",[_._v("区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加"),v("code",[_._v("_copy")]),_._v("。")])]),_._v(" "),v("h2",{attrs:{id:"特定容器算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特定容器算法"}},[_._v("#")]),_._v(" 特定容器算法")]),_._v(" "),v("ul",[v("li",[_._v("对于"),v("code",[_._v("list")]),_._v("和"),v("code",[_._v("forward_list")]),_._v("，优先使用成员函数版本的算法而不是通用算法。")])]),_._v(" "),v("p",[v("strong",[_._v("list和forward_list成员函数版本的算法")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("lst.merge(lst2)")])]),_._v(" "),v("td",[_._v("将来自"),v("code",[_._v("lst2")]),_._v("的元素合并入"),v("code",[_._v("lst")]),_._v("，二者都必须是有序的，元素将从"),v("code",[_._v("lst2")]),_._v("中删除。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.merge(lst2, comp)")])]),_._v(" "),v("td",[_._v("同上，给定比较操作。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.remove(val)")])]),_._v(" "),v("td",[_._v("调用"),v("code",[_._v("erase")]),_._v("删除掉与给定值相等(==)的每个元素")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.remove_if(pred)")])]),_._v(" "),v("td",[_._v("调用"),v("code",[_._v("erase")]),_._v("删除掉令一元谓词为真的每个元素")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.reverse()")])]),_._v(" "),v("td",[_._v("反转"),v("code",[_._v("lst")]),_._v("中元素的顺序")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.sort()")])]),_._v(" "),v("td",[_._v("使用"),v("code",[_._v("<")]),_._v("排序元素")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.sort(comp)")])]),_._v(" "),v("td",[_._v("使用给定比较操作排序元素")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.unique()")])]),_._v(" "),v("td",[_._v("调用"),v("code",[_._v("erase")]),_._v("删除同一个值的连续拷贝。使用"),v("code",[_._v("==")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("lst.unique(pred)")])]),_._v(" "),v("td",[_._v("调用"),v("code",[_._v("erase")]),_._v("删除同一个值的连续拷贝。使用给定的二元谓词。")])])])]),_._v(" "),v("ul",[v("li",[_._v("上面的操作都返回"),v("code",[_._v("void")])])]),_._v(" "),v("p",[v("strong",[_._v("list和forward_list的splice成员函数版本的参数")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("参数")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("(p, lst2)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("是一个指向"),v("code",[_._v("lst")]),_._v("中元素的迭代器，或者一个指向"),v("code",[_._v("flst")]),_._v("首前位置的迭代器。函数将"),v("code",[_._v("lst2")]),_._v("中的所有元素移动到"),v("code",[_._v("lst")]),_._v("中"),v("code",[_._v("p")]),_._v("之前的位置或是"),v("code",[_._v("flst")]),_._v("中"),v("code",[_._v("p")]),_._v("之后的位置。将元素从"),v("code",[_._v("lst2")]),_._v("中删除。"),v("code",[_._v("lst2")]),_._v("的类型必须和"),v("code",[_._v("lst")]),_._v("相同，而且不能是同一个链表。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("(p, lst2, p2)")])]),_._v(" "),v("td",[_._v("同上，"),v("code",[_._v("p2")]),_._v("是一个指向"),v("code",[_._v("lst2")]),_._v("中位置的有效的迭代器，将"),v("code",[_._v("p2")]),_._v("指向的元素移动到"),v("code",[_._v("lst")]),_._v("中，或将"),v("code",[_._v("p2")]),_._v("之后的元素移动到"),v("code",[_._v("flst")]),_._v("中。"),v("code",[_._v("lst2")]),_._v("可以是于"),v("code",[_._v("lst")]),_._v("或"),v("code",[_._v("flst")]),_._v("相同的链表。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("(p, lst2, b, e)")])]),_._v(" "),v("td",[v("code",[_._v("b")]),_._v("和"),v("code",[_._v("e")]),_._v("表示"),v("code",[_._v("lst2")]),_._v("中的合法范围。将给定范围中的元素从"),v("code",[_._v("lst2")]),_._v("移动到"),v("code",[_._v("lst")]),_._v("或"),v("code",[_._v("first")]),_._v("中。"),v("code",[_._v("lst2")]),_._v("与"),v("code",[_._v("lst")]),_._v("可以使相同的链表，但"),v("code",[_._v("p")]),_._v("不能指向给定范围中的元素。")])])])]),_._v(" "),v("ul",[v("li",[_._v("使用"),v("code",[_._v("lst.splice(args)")]),_._v("或"),v("code",[_._v("flst.splice_after(args)")])])])])}),[],!1,null,null,null);v.default=d.exports}}]);