(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{444:function(v,_,t){"use strict";t.r(_);var l=t(11),r=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"第十三章-拷贝控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第十三章-拷贝控制"}},[v._v("#")]),v._v(" 第十三章 拷贝控制")]),v._v(" "),_("p",[_("strong",[v._v("拷贝控制操作")]),v._v("（copy control）:")]),v._v(" "),_("ul",[_("li",[v._v("拷贝构造函数（copy constructor）")]),v._v(" "),_("li",[v._v("拷贝赋值运算符（copy-assignment operator）")]),v._v(" "),_("li",[v._v("移动构造函数（move constructor）")]),v._v(" "),_("li",[v._v("移动赋值函数（move-assignement operator）")]),v._v(" "),_("li",[v._v("析构函数（destructor）")])]),v._v(" "),_("h2",{attrs:{id:"拷贝、赋值和销毁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拷贝、赋值和销毁"}},[v._v("#")]),v._v(" 拷贝、赋值和销毁")]),v._v(" "),_("h3",{attrs:{id:"拷贝构造函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拷贝构造函数"}},[v._v("#")]),v._v(" 拷贝构造函数")]),v._v(" "),_("ul",[_("li",[v._v("如果一个构造函数的第一个参数是"),_("strong",[v._v("自身类类型的引用")]),v._v("，且任何额外参数都有默认值，则此构造函数是"),_("strong",[v._v("拷贝构造函数")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("class Foo{ public: Foo(const Foo&); }")])]),v._v(" "),_("li",[_("strong",[v._v("合成的拷贝构造函数")]),v._v("（synthesized copy constructor）：会将参数的成员逐个拷贝到正在创建的对象中。")]),v._v(" "),_("li",[_("strong",[v._v("拷贝初始化")]),v._v("：\n"),_("ul",[_("li",[v._v("将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。")]),v._v(" "),_("li",[v._v("通常使用拷贝构造函数完成。")]),v._v(" "),_("li",[_("code",[v._v('string book = "9-99";')])]),v._v(" "),_("li",[v._v("出现场景：\n"),_("ul",[_("li",[v._v("用"),_("code",[v._v("=")]),v._v("定义变量时。")]),v._v(" "),_("li",[v._v("将一个对象作为实参传递给一个非引用类型的形参。")]),v._v(" "),_("li",[v._v("从一个返回类型为非引用类型的函数返回一个对象。")]),v._v(" "),_("li",[v._v("用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。")])])])])])]),v._v(" "),_("h3",{attrs:{id:"拷贝赋值运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拷贝赋值运算符"}},[v._v("#")]),v._v(" 拷贝赋值运算符")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("重载赋值运算符")]),v._v("：\n"),_("ul",[_("li",[v._v("重写一个名为"),_("code",[v._v("operator=")]),v._v("的函数.")]),v._v(" "),_("li",[v._v("通常返回一个指向其左侧运算对象的引用。")]),v._v(" "),_("li",[_("code",[v._v("Foo& operator=(const Foo&);")])])])]),v._v(" "),_("li",[_("strong",[v._v("合成拷贝赋值运算符")]),v._v("：\n"),_("ul",[_("li",[v._v("将右侧运算对象的每个非"),_("code",[v._v("static")]),v._v("成员赋予左侧运算对象的对应成员。")])])])]),v._v(" "),_("h3",{attrs:{id:"析构函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#析构函数"}},[v._v("#")]),v._v(" 析构函数")]),v._v(" "),_("ul",[_("li",[v._v("释放对象所使用的资源，并销毁对象的非"),_("code",[v._v("static")]),v._v("数据成员。")]),v._v(" "),_("li",[v._v("名字由波浪号接类名构成。没有返回值，也不接受参数。")]),v._v(" "),_("li",[_("code",[v._v("~Foo();")])]),v._v(" "),_("li",[v._v("调用时机：\n"),_("ul",[_("li",[v._v("变量在离开其作用域时。")]),v._v(" "),_("li",[v._v("当一个对象被销毁时，其成员被销毁。")]),v._v(" "),_("li",[v._v("容器被销毁时，其元素被销毁。")]),v._v(" "),_("li",[v._v("动态分配的对象，当对指向它的指针应用"),_("code",[v._v("delete")]),v._v("运算符时。")]),v._v(" "),_("li",[v._v("对于临时对象，当创建它的完整表达式结束时。")])])]),v._v(" "),_("li",[_("strong",[v._v("合成析构函数")]),v._v("：\n"),_("ul",[_("li",[v._v("空函数体执行完后，"),_("strong",[v._v("成员会被自动销毁。")])]),v._v(" "),_("li",[v._v("注意：析构函数体本身并不直接销毁成员。")])])])]),v._v(" "),_("h3",{attrs:{id:"三-五法则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三-五法则"}},[v._v("#")]),v._v(" 三/五法则")]),v._v(" "),_("ul",[_("li",[v._v("需要析构函数的类也需要拷贝和赋值操作。")]),v._v(" "),_("li",[v._v("需要拷贝操作的类也需要赋值操作，反之亦然。")])]),v._v(" "),_("h3",{attrs:{id:"使用-default"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-default"}},[v._v("#")]),v._v(" 使用=default")]),v._v(" "),_("ul",[_("li",[v._v("可以通过将拷贝控制成员定义为"),_("code",[v._v("=default")]),v._v("来显式地要求编译器生成合成的版本。")]),v._v(" "),_("li",[v._v("合成的函数将隐式地声明为内联的。")])]),v._v(" "),_("h3",{attrs:{id:"阻止拷贝"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阻止拷贝"}},[v._v("#")]),v._v(" 阻止拷贝")]),v._v(" "),_("ul",[_("li",[v._v("大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。")]),v._v(" "),_("li",[v._v("定义删除的函数："),_("code",[v._v("=delete")]),v._v("。")]),v._v(" "),_("li",[v._v("虽然声明了它们，但是不能以任何方式使用它们。")]),v._v(" "),_("li",[v._v("析构函数不能是删除的成员。")]),v._v(" "),_("li",[v._v("如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。")]),v._v(" "),_("li",[v._v("老版本使用"),_("code",[v._v("private")]),v._v("声明来阻止拷贝。")])]),v._v(" "),_("h2",{attrs:{id:"拷贝控制和资源管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拷贝控制和资源管理"}},[v._v("#")]),v._v(" 拷贝控制和资源管理")]),v._v(" "),_("ul",[_("li",[v._v("类的行为可以像一个值，也可以像一个指针。\n"),_("ul",[_("li",[v._v("行为像值：对象有自己的状态，副本和原对象是完全独立的。")]),v._v(" "),_("li",[v._v("行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。")])])])]),v._v(" "),_("h2",{attrs:{id:"交换操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#交换操作"}},[v._v("#")]),v._v(" 交换操作")]),v._v(" "),_("ul",[_("li",[v._v("管理资源的类通常还定义一个名为"),_("code",[v._v("swap")]),v._v("的函数。")]),v._v(" "),_("li",[v._v("经常用于重排元素顺序的算法。")]),v._v(" "),_("li",[v._v("用"),_("code",[v._v("swap")]),v._v("而不是"),_("code",[v._v("std::swap")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"对象移动"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象移动"}},[v._v("#")]),v._v(" 对象移动")]),v._v(" "),_("ul",[_("li",[v._v("很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。")]),v._v(" "),_("li",[v._v("在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。")]),v._v(" "),_("li",[v._v("标准库容器、"),_("code",[v._v("string")]),v._v("和"),_("code",[v._v("shared_ptr")]),v._v("类既可以支持移动也支持拷贝。"),_("code",[v._v("IO")]),v._v("类和"),_("code",[v._v("unique_ptr")]),v._v("类可以移动但不能拷贝。")])]),v._v(" "),_("h3",{attrs:{id:"右值引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#右值引用"}},[v._v("#")]),v._v(" 右值引用")]),v._v(" "),_("ul",[_("li",[v._v("新标准引入右值引用以支持移动操作。")]),v._v(" "),_("li",[v._v("通过"),_("code",[v._v("&&")]),v._v("获得右值引用。")]),v._v(" "),_("li",[v._v("只能绑定到一个将要销毁的对象。")]),v._v(" "),_("li",[v._v("常规引用可以称之为左值引用。")]),v._v(" "),_("li",[v._v("左值持久，右值短暂。")])]),v._v(" "),_("p",[_("strong",[v._v("move函数")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("int &&rr2 = std::move(rr1);")])]),v._v(" "),_("li",[_("code",[v._v("move")]),v._v("告诉编译器，我们有一个左值，但我希望像右值一样处理它。")]),v._v(" "),_("li",[v._v("调用"),_("code",[v._v("move")]),v._v("意味着：除了对"),_("code",[v._v("rr1")]),v._v("赋值或者销毁它外，我们将不再使用它。")])]),v._v(" "),_("h3",{attrs:{id:"移动构造函数和移动赋值运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#移动构造函数和移动赋值运算符"}},[v._v("#")]),v._v(" 移动构造函数和移动赋值运算符")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("移动构造函数")]),v._v("：\n"),_("ul",[_("li",[v._v("第一个参数是该类类型的一个引用，关键是，这个引用参数是一个"),_("strong",[v._v("右值引用")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("StrVec::StrVec(StrVec &&s) noexcept{}")])]),v._v(" "),_("li",[v._v("不分配任何新内存，只是接管给定的内存。")])])]),v._v(" "),_("li",[_("strong",[v._v("移动赋值运算符")]),v._v("：\n"),_("ul",[_("li",[_("code",[v._v("StrVec& StrVec::operator=(StrVec && rhs) noexcept{}")])])])]),v._v(" "),_("li",[v._v("移动右值，拷贝左值。")]),v._v(" "),_("li",[v._v("如果没有移动构造函数，右值也被拷贝。")]),v._v(" "),_("li",[v._v("更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。")]),v._v(" "),_("li",[v._v("移动迭代器：\n"),_("ul",[_("li",[_("code",[v._v("make_move_iterator")]),v._v("函数讲一个普通迭代器转换为一个移动迭代器。")])])]),v._v(" "),_("li",[v._v("建议：小心地使用移动操作，以获得性能提升。")])]),v._v(" "),_("h3",{attrs:{id:"右值引用和成员函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#右值引用和成员函数"}},[v._v("#")]),v._v(" 右值引用和成员函数")]),v._v(" "),_("ul",[_("li",[v._v("区分移动和拷贝的重载函数通常有一个版本接受一个"),_("code",[v._v("const T&")]),v._v("，而另一个版本接受一个"),_("code",[v._v("T&&")]),v._v("。")]),v._v(" "),_("li",[v._v("引用限定符：\n"),_("ul",[_("li",[v._v("在参数列表后面防止一个"),_("code",[v._v("&")]),v._v("，限定只能向可修改的左值赋值而不能向右值赋值。")])])])])])}),[],!1,null,null,null);_.default=r.exports}}]);