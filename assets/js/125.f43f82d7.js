(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{443:function(_,v,e){"use strict";e.r(v);var d=e(11),t=Object(d.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"第十二章-动态内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第十二章-动态内存"}},[_._v("#")]),_._v(" 第十二章 动态内存")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("对象的生命周期：")]),_._v(" "),v("ul",[v("li",[_._v("全局对象在程序启动时分配，结束时销毁。")]),_._v(" "),v("li",[_._v("局部对象在进入程序块时创建，离开块时销毁。")]),_._v(" "),v("li",[_._v("局部"),v("code",[_._v("static")]),_._v("对象在第一次使用前分配，在程序结束时销毁。")]),_._v(" "),v("li",[_._v("动态分配对象：只能显式地被释放。")])])]),_._v(" "),v("li",[v("p",[_._v("对象的内存位置：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("静态内存")]),_._v("用来保存局部"),v("code",[_._v("static")]),_._v("对象、类"),v("code",[_._v("static")]),_._v("对象、定义在任何函数之外的变量。")]),_._v(" "),v("li",[v("strong",[_._v("栈内存")]),_._v("用来保存定义在函数内的非"),v("code",[_._v("static")]),_._v("对象。")]),_._v(" "),v("li",[v("strong",[_._v("堆内存")]),_._v("，又称自由空间，用来存储"),v("strong",[_._v("动态分配")]),_._v("的对象。")])])])]),_._v(" "),v("h2",{attrs:{id:"动态内存与智能指针"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态内存与智能指针"}},[_._v("#")]),_._v(" 动态内存与智能指针")]),_._v(" "),v("ul",[v("li",[_._v("动态内存管理：\n"),v("ul",[v("li",[v("code",[_._v("new")]),_._v("：在动态内存中为对象分配空间并返回一个指向该对象的指针。")]),_._v(" "),v("li",[v("code",[_._v("delete")]),_._v("：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。")])])]),_._v(" "),v("li",[_._v("智能指针：\n"),v("ul",[v("li",[_._v("管理动态对象。")]),_._v(" "),v("li",[_._v("行为类似常规指针。")]),_._v(" "),v("li",[_._v("负责自动释放所指向的对象。")]),_._v(" "),v("li",[_._v("智能指针也是模板。")])])])]),_._v(" "),v("h3",{attrs:{id:"shared-ptr类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared-ptr类"}},[_._v("#")]),_._v(" shared_ptr类")]),_._v(" "),v("p",[v("strong",[_._v("shared_ptr和unique_ptr都支持的操作")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("shared_ptr<T> sp")]),_._v(" "),v("code",[_._v("unique_ptr<T> up")])]),_._v(" "),v("td",[_._v("空智能指针，可以指向类型是"),v("code",[_._v("T")]),_._v("的对象")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p")])]),_._v(" "),v("td",[_._v("将"),v("code",[_._v("p")]),_._v("用作一个条件判断，若"),v("code",[_._v("p")]),_._v("指向一个对象，则为"),v("code",[_._v("true")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("*p")])]),_._v(" "),v("td",[_._v("解引用"),v("code",[_._v("p")]),_._v("，获得它指向的对象。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p->mem")])]),_._v(" "),v("td",[_._v("等价于"),v("code",[_._v("(*p).mem")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.get()")])]),_._v(" "),v("td",[_._v("返回"),v("code",[_._v("p")]),_._v("中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("swap(p, q)")]),_._v(" "),v("code",[_._v("p.swap(q)")])]),_._v(" "),v("td",[_._v("交换"),v("code",[_._v("p")]),_._v("和"),v("code",[_._v("q")]),_._v("中的指针")])])])]),_._v(" "),v("p",[v("strong",[_._v("shared_ptr独有的操作")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("make_shared<T>(args)")])]),_._v(" "),v("td",[_._v("返回一个"),v("code",[_._v("shared_ptr")]),_._v("，指向一个动态分配的类型为"),v("code",[_._v("T")]),_._v("的对象。使用"),v("code",[_._v("args")]),_._v("初始化此对象。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("shared_ptr<T>p(q)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("是"),v("code",[_._v("shared_ptr q")]),_._v("的拷贝；此操作会"),v("strong",[_._v("递增")]),v("code",[_._v("q")]),_._v("中的计数器。"),v("code",[_._v("q")]),_._v("中的指针必须能转换为"),v("code",[_._v("T*")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p = q")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("和"),v("code",[_._v("q")]),_._v("都是"),v("code",[_._v("shared_ptr")]),_._v("，所保存的指针必须能互相转换。此操作会"),v("strong",[_._v("递减")]),v("code",[_._v("p")]),_._v("的引用计数，"),v("strong",[_._v("递增")]),v("code",[_._v("q")]),_._v("的引用计数；若"),v("code",[_._v("p")]),_._v("的引用计数变为0，则将其管理的原内存释放。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.unique()")])]),_._v(" "),v("td",[_._v("若"),v("code",[_._v("p.use_count()")]),_._v("是1，返回"),v("code",[_._v("true")]),_._v("；否则返回"),v("code",[_._v("false")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.use_count()")])]),_._v(" "),v("td",[_._v("返回与"),v("code",[_._v("p")]),_._v("共享对象的智能指针数量；可能很慢，主要用于调试。")])])])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("使用动态内存的三种原因")]),_._v("：\n"),v("ul",[v("li",[_._v("程序不知道自己需要使用多少对象（比如容器类）。")]),_._v(" "),v("li",[_._v("程序不知道所需要对象的准确类型。")]),_._v(" "),v("li",[_._v("程序需要在多个对象间共享数据。")])])])]),_._v(" "),v("h3",{attrs:{id:"直接管理内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接管理内存"}},[_._v("#")]),_._v(" 直接管理内存")]),_._v(" "),v("ul",[v("li",[_._v("用"),v("code",[_._v("new")]),_._v("动态分配和初始化对象。\n"),v("ul",[v("li",[v("code",[_._v("new")]),_._v("无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。")]),_._v(" "),v("li",[v("code",[_._v("int *pi = new int(123);")])]),_._v(" "),v("li",[_._v("一旦内存耗尽，会抛出类型是"),v("code",[_._v("bad_alloc")]),_._v("的异常。")])])]),_._v(" "),v("li",[_._v("用"),v("code",[_._v("delete")]),_._v("将动态内存归还给系统。\n"),v("ul",[v("li",[_._v("接受一个指针，指向要释放的对象。")]),_._v(" "),v("li",[v("code",[_._v("delete")]),_._v("后的指针称为空悬指针（dangling pointer）。")])])]),_._v(" "),v("li",[_._v("使用"),v("code",[_._v("new")]),_._v("和"),v("code",[_._v("delete")]),_._v("管理动态内存存在三个常见问题：\n"),v("ul",[v("li",[_._v("1.忘记"),v("code",[_._v("delete")]),_._v("内存。")]),_._v(" "),v("li",[_._v("2.使用已经释放掉的对象。")]),_._v(" "),v("li",[_._v("3.同一块内存释放两次。")])])]),_._v(" "),v("li",[_._v("坚持只使用智能指针可以避免上述所有问题。")])]),_._v(" "),v("h3",{attrs:{id:"shared-ptr和new结合使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#shared-ptr和new结合使用"}},[_._v("#")]),_._v(" shared_ptr和new结合使用")]),_._v(" "),v("p",[v("strong",[_._v("定义和改变shared_ptr的其他方法")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("shared_ptr<T> p(q)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("管理内置指针"),v("code",[_._v("q")]),_._v("所指向的对象；"),v("code",[_._v("q")]),_._v("必须指向"),v("code",[_._v("new")]),_._v("分配的内存，且能够转换为"),v("code",[_._v("T*")]),_._v("类型")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("shared_ptr<T> p(u)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("从"),v("code",[_._v("unique_ptr u")]),_._v("那里接管了对象的所有权；将"),v("code",[_._v("u")]),_._v("置为空")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("shared_ptr<T> p(q, d)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("接管了内置指针"),v("code",[_._v("q")]),_._v("所指向的对象的所有权。"),v("code",[_._v("q")]),_._v("必须能转换为"),v("code",[_._v("T*")]),_._v("类型。"),v("code",[_._v("p")]),_._v("将使用可调用对象"),v("code",[_._v("d")]),_._v("来代替"),v("code",[_._v("delete")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("shared_ptr<T> p(p2, d)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("是"),v("code",[_._v("shared_ptr p2")]),_._v("的拷贝，唯一的区别是"),v("code",[_._v("p")]),_._v("将可调用对象"),v("code",[_._v("d")]),_._v("来代替"),v("code",[_._v("delete")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.reset()")])]),_._v(" "),v("td",[_._v("若"),v("code",[_._v("p")]),_._v("是唯一指向其对象的"),v("code",[_._v("shared_ptr")]),_._v("，"),v("code",[_._v("reset")]),_._v("会释放此对象。若传递了可选的参数内置指针"),v("code",[_._v("q")]),_._v("，会令"),v("code",[_._v("p")]),_._v("指向"),v("code",[_._v("q")]),_._v("，否则会将"),v("code",[_._v("p")]),_._v("置空。若还传递了参数"),v("code",[_._v("d")]),_._v("，则会调用"),v("code",[_._v("d")]),_._v("而不是"),v("code",[_._v("delete")]),_._v("来释放"),v("code",[_._v("q")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.reset(q)")])]),_._v(" "),v("td",[_._v("同上")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("p.reset(q, d)")])]),_._v(" "),v("td",[_._v("同上")])])])]),_._v(" "),v("h3",{attrs:{id:"智能指针和异常"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#智能指针和异常"}},[_._v("#")]),_._v(" 智能指针和异常")]),_._v(" "),v("ul",[v("li",[_._v("如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。")]),_._v(" "),v("li",[v("strong",[_._v("智能指针陷阱")]),_._v("：\n"),v("ul",[v("li",[_._v("不用相同的内置指针初始化（或"),v("code",[_._v("reset")]),_._v("）多个智能指针")]),_._v(" "),v("li",[_._v("不"),v("code",[_._v("delete get()")]),_._v("返回的指针。")]),_._v(" "),v("li",[_._v("如果你使用"),v("code",[_._v("get()")]),_._v("返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。")]),_._v(" "),v("li",[_._v("如果你使用智能指针管理的资源不是"),v("code",[_._v("new")]),_._v("分配的内存，记住传递给它一个删除器。")])])])]),_._v(" "),v("h3",{attrs:{id:"unique-ptr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#unique-ptr"}},[_._v("#")]),_._v(" unique_ptr")]),_._v(" "),v("ul",[v("li",[_._v("某一个时刻只能有一个"),v("code",[_._v("unique_ptr")]),_._v("指向一个给定的对象。")]),_._v(" "),v("li",[_._v("不支持拷贝或者赋值操作。")]),_._v(" "),v("li",[_._v("向后兼容："),v("code",[_._v("auto_ptr")]),_._v("：老版本，具有"),v("code",[_._v("unique_ptr")]),_._v("的部分特性。特别是，不能在容器中保存"),v("code",[_._v("auto_ptr")]),_._v("，也不能从函数返回"),v("code",[_._v("auto_ptr")]),_._v("。")])]),_._v(" "),v("p",[v("strong",[_._v("unique_ptr操作")]),_._v(":")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("unique_ptr<T> u1")])]),_._v(" "),v("td",[_._v("空"),v("code",[_._v("unique_ptr")]),_._v("，可以指向类型是"),v("code",[_._v("T")]),_._v("的对象。"),v("code",[_._v("u1")]),_._v("会使用"),v("code",[_._v("delete")]),_._v("来是释放它的指针。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("unique_ptr<T, D> u2")])]),_._v(" "),v("td",[v("code",[_._v("u2")]),_._v("会使用一个类型为"),v("code",[_._v("D")]),_._v("的可调用对象来释放它的指针。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("unique_ptr<T, D> u(d)")])]),_._v(" "),v("td",[_._v("空"),v("code",[_._v("unique_ptr")]),_._v("，指向类型为"),v("code",[_._v("T")]),_._v("的对象，用类型为"),v("code",[_._v("D")]),_._v("的对象"),v("code",[_._v("d")]),_._v("代替"),v("code",[_._v("delete")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u = nullptr")])]),_._v(" "),v("td",[_._v("释放"),v("code",[_._v("u")]),_._v("指向的对象，将"),v("code",[_._v("u")]),_._v("置为空。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u.release()")])]),_._v(" "),v("td",[v("code",[_._v("u")]),_._v("放弃对指针的控制权，返回指针，并将"),v("code",[_._v("u")]),_._v("置空。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u.reset()")])]),_._v(" "),v("td",[_._v("释放"),v("code",[_._v("u")]),_._v("指向的对象")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u.reset(q)")])]),_._v(" "),v("td",[_._v("令"),v("code",[_._v("u")]),_._v("指向"),v("code",[_._v("q")]),_._v("指向的对象")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u.reset(nullptr)")])]),_._v(" "),v("td",[_._v("将"),v("code",[_._v("u")]),_._v("置空")])])])]),_._v(" "),v("h3",{attrs:{id:"weak-ptr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weak-ptr"}},[_._v("#")]),_._v(" weak_ptr")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("weak_ptr")]),_._v("是一种不控制所指向对象生存期的智能指针。")]),_._v(" "),v("li",[_._v("指向一个由"),v("code",[_._v("shared_ptr")]),_._v("管理的对象，不改变"),v("code",[_._v("shared_ptr")]),_._v("的引用计数。")]),_._v(" "),v("li",[_._v("一旦最后一个指向对象的"),v("code",[_._v("shared_ptr")]),_._v("被销毁，对象就会被释放，不管有没有"),v("code",[_._v("weak_ptr")]),_._v("指向该对象。")])]),_._v(" "),v("p",[v("strong",[_._v("weak_ptr操作")]),_._v(":")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("weak_ptr<T> w")])]),_._v(" "),v("td",[_._v("空"),v("code",[_._v("weak_ptr")]),_._v("可以指向类型为"),v("code",[_._v("T")]),_._v("的对象")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("weak_ptr<T> w(sp)")])]),_._v(" "),v("td",[_._v("与"),v("code",[_._v("shared_ptr")]),_._v("指向相同对象的"),v("code",[_._v("weak_ptr")]),_._v("。"),v("code",[_._v("T")]),_._v("必须能转换为"),v("code",[_._v("sp")]),_._v("指向的类型。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("w = p")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("可以是"),v("code",[_._v("shared_ptr")]),_._v("或一个"),v("code",[_._v("weak_ptr")]),_._v("。赋值后"),v("code",[_._v("w")]),_._v("和"),v("code",[_._v("p")]),_._v("共享对象。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("w.reset()")])]),_._v(" "),v("td",[_._v("将"),v("code",[_._v("w")]),_._v("置为空。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("w.use_count()")])]),_._v(" "),v("td",[_._v("与"),v("code",[_._v("w")]),_._v("共享对象的"),v("code",[_._v("shared_ptr")]),_._v("的数量。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("w.expired()")])]),_._v(" "),v("td",[_._v("若"),v("code",[_._v("w.use_count()")]),_._v("为0，返回"),v("code",[_._v("true")]),_._v("，否则返回"),v("code",[_._v("false")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("w.lock()")])]),_._v(" "),v("td",[_._v("如果"),v("code",[_._v("expired")]),_._v("为"),v("code",[_._v("true")]),_._v("，则返回一个空"),v("code",[_._v("shared_ptr")]),_._v("；否则返回一个指向"),v("code",[_._v("w")]),_._v("的对象的"),v("code",[_._v("shared_ptr")]),_._v("。")])])])]),_._v(" "),v("h2",{attrs:{id:"动态数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态数组"}},[_._v("#")]),_._v(" 动态数组")]),_._v(" "),v("h3",{attrs:{id:"new和数组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#new和数组"}},[_._v("#")]),_._v(" new和数组")]),_._v(" "),v("ul",[v("li",[v("p",[v("code",[_._v("new")]),_._v("一个动态数组：")]),_._v(" "),v("ul",[v("li",[_._v("类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。")]),_._v(" "),v("li",[_._v("返回"),v("strong",[_._v("指向第一个对象的指针")]),_._v("。")]),_._v(" "),v("li",[v("code",[_._v("int *p = new int[size];")])])])]),_._v(" "),v("li",[v("p",[v("code",[_._v("delete")]),_._v("一个动态数组：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("delete [] p;")])])])]),_._v(" "),v("li",[v("p",[v("code",[_._v("unique_ptr")]),_._v("和数组：")]),_._v(" "),v("ul",[v("li",[_._v("指向数组的"),v("code",[_._v("unique_ptr")]),_._v("不支持成员访问运算符（点和箭头）。")])])])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("unique_ptr<T[]> u")])]),_._v(" "),v("td",[v("code",[_._v("u")]),_._v("可以指向一个动态分配的数组，整数元素类型为"),v("code",[_._v("T")])])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("unique_ptr<T[]> u(p)")])]),_._v(" "),v("td",[v("code",[_._v("u")]),_._v("指向内置指针"),v("code",[_._v("p")]),_._v("所指向的动态分配的数组。"),v("code",[_._v("p")]),_._v("必须能转换为类型"),v("code",[_._v("T*")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("u[i]")])]),_._v(" "),v("td",[_._v("返回"),v("code",[_._v("u")]),_._v("拥有的数组中位置"),v("code",[_._v("i")]),_._v("处的对象。"),v("code",[_._v("u")]),_._v("必须指向一个数组。")])])])]),_._v(" "),v("h3",{attrs:{id:"allocator类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#allocator类"}},[_._v("#")]),_._v(" allocator类")]),_._v(" "),v("ul",[v("li",[_._v("标准库"),v("code",[_._v("allocator")]),_._v("类定义在头文件"),v("code",[_._v("memory")]),_._v("中，帮助我们将内存分配和对象构造分离开。")]),_._v(" "),v("li",[_._v("分配的是原始的、未构造的内存。")]),_._v(" "),v("li",[v("code",[_._v("allocator")]),_._v("是一个模板。")]),_._v(" "),v("li",[v("code",[_._v("allocator<string> alloc;")])])]),_._v(" "),v("p",[v("strong",[_._v("标准库allocator类及其算法")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("allocator<T> a")])]),_._v(" "),v("td",[_._v("定义了一个名为"),v("code",[_._v("a")]),_._v("的"),v("code",[_._v("allocator")]),_._v("对象，它可以为类型为"),v("code",[_._v("T")]),_._v("的对象分配内存")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("a.allocate(n)")])]),_._v(" "),v("td",[_._v("分配一段原始的、未构造的内存，保存"),v("code",[_._v("n")]),_._v("个类型为"),v("code",[_._v("T")]),_._v("的对象。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("a.deallocate(p, n)")])]),_._v(" "),v("td",[_._v("释放从"),v("code",[_._v("T*")]),_._v("指针"),v("code",[_._v("p")]),_._v("中地址开始的内存，这块内存保存了"),v("code",[_._v("n")]),_._v("个类型为"),v("code",[_._v("T")]),_._v("的对象；"),v("code",[_._v("p")]),_._v("必须是一个先前由"),v("code",[_._v("allocate")]),_._v("返回的指针。且"),v("code",[_._v("n")]),_._v("必须是"),v("code",[_._v("p")]),_._v("创建时所要求的大小。在调用"),v("code",[_._v("deallocate")]),_._v("之前，用户必须对每个在这块内存中创建的对象调用"),v("code",[_._v("destroy")]),_._v("。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("a.construct(p, args)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("必须是一个类型是"),v("code",[_._v("T*")]),_._v("的指针，指向一块原始内存；"),v("code",[_._v("args")]),_._v("被传递给类型为"),v("code",[_._v("T")]),_._v("的构造函数，用来在"),v("code",[_._v("p")]),_._v("指向的内存中构造一个对象。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("a.destroy(p)")])]),_._v(" "),v("td",[v("code",[_._v("p")]),_._v("为"),v("code",[_._v("T*")]),_._v("类型的指针，此算法对"),v("code",[_._v("p")]),_._v("指向的对象执行析构函数。")])])])]),_._v(" "),v("p",[v("strong",[_._v("allocator伴随算法")]),_._v("：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("操作")]),_._v(" "),v("th",[_._v("解释")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("uninitialized_copy(b, e, b2)")])]),_._v(" "),v("td",[_._v("从迭代器"),v("code",[_._v("b")]),_._v("和"),v("code",[_._v("e")]),_._v("给定的输入范围中拷贝元素到迭代器"),v("code",[_._v("b2")]),_._v("指定的未构造的原始内存中。"),v("code",[_._v("b2")]),_._v("指向的内存必须足够大，能够容纳输入序列中元素的拷贝。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("uninitialized_copy_n(b, n, b2)")])]),_._v(" "),v("td",[_._v("从迭代器"),v("code",[_._v("b")]),_._v("指向的元素开始，拷贝"),v("code",[_._v("n")]),_._v("个元素到"),v("code",[_._v("b2")]),_._v("开始的内存中。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("uninitialized_fill(b, e, t)")])]),_._v(" "),v("td",[_._v("在迭代器"),v("code",[_._v("b")]),_._v("和"),v("code",[_._v("e")]),_._v("执行的原始内存范围中创建对象，对象的值均为"),v("code",[_._v("t")]),_._v("的拷贝。")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("uninitialized_fill_n(b, n, t)")])]),_._v(" "),v("td",[_._v("从迭代器"),v("code",[_._v("b")]),_._v("指向的内存地址开始创建"),v("code",[_._v("n")]),_._v("个对象。"),v("code",[_._v("b")]),_._v("必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。")])])])]),_._v(" "),v("ul",[v("li",[_._v("定义在头文件"),v("code",[_._v("memory")]),_._v("中。")]),_._v(" "),v("li",[_._v("在给定目的位置创建元素，而不是由系统分配内存给他们。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);